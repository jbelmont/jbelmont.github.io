<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Oriented Design on Software Musings</title>
    <link>https://www.marcelbelmont.com/tags/object-oriented-design/</link>
    <description>Recent content in Object Oriented Design on Software Musings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Jean-Marcel Belmont</copyright>
    <lastBuildDate>Tue, 22 Aug 2017 12:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/object-oriented-design/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Growing Object-Oriented Software, Guided by Tests</title>
      <link>https://www.marcelbelmont.com/post/growing-object-oriented-software-guided-by-tests/</link>
      <pubDate>Tue, 22 Aug 2017 12:00:00 +0000</pubDate>
      
      <guid>https://www.marcelbelmont.com/post/growing-object-oriented-software-guided-by-tests/</guid>
      <description>

&lt;h1 id=&#34;growing-object-oriented-software-guided-by-tests&#34;&gt;Growing Object Oriented Software Guided By Tests&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#what-is-the-point-of-test-driven-development&#34;&gt;What is the Point of Test-Driven Development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#test-driven-development-with-objects&#34;&gt;Test-Driven Development with Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#an-introduction-to-the-tools&#34;&gt;An Introduction to the Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kick-starting-the-test-driven-cycle&#34;&gt;Kick-Starting the Test-Driven Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#maintaining-the-test-driven-cycle&#34;&gt;Maintaining The Test-Driven Cycle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#object-oriented-style&#34;&gt;Object-Oriented Style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;achieving-object-oriented-design&#34; target=&#34;_blank&#34;&gt;Achieving Object-Oriented Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-on-third-party-code&#34;&gt;Building on Third-Party Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#commissioning-on-auction-sniper&#34;&gt;Commissioning on Auction Sniper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-walking-skeleton&#34;&gt;The Walking Skeleton&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#passing-the-first-test&#34;&gt;Passing the First Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chapters-12-to-18&#34;&gt;Chapters 12 to 18&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sniping-for-multiple-items&#34;&gt;Sniping for Multiple Items&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#teasing-apart-main&#34;&gt;Teasing apart Main&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#filling-in-the-details&#34;&gt;Filling in the Details&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#listening-to-the-tests&#34;&gt;Listening to the Tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#test-readability&#34;&gt;Test Readability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#constructing-complex-test-data&#34;&gt;Constructing Complex Test Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#test-diagnostics&#34;&gt;Test Diagnostics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#test-flexibility&#34;&gt;Test Flexibility&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chapters-25-to-27&#34;&gt;Chapters 25 to 27&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-is-the-point-of-test-driven-development&#34;&gt;What is the Point of Test-Driven Development&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Feedback is the most fundamental tool at our disposal&lt;/li&gt;
&lt;li&gt;TDD is a practice that supports change&lt;/li&gt;
&lt;li&gt;You should never write new functionality without a failing test.&lt;/li&gt;
&lt;li&gt;This first chapter basically explains the benefits of TDD&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;test-driven-development-with-objects&#34;&gt;Test-Driven Development with Objects&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Objects should communicate their intent to other objects

&lt;ul&gt;
&lt;li&gt;Tell Don&amp;rsquo;t Ask principle&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Mock Objects when you use &amp;ldquo;Tell Don&amp;rsquo;t Ask&amp;rdquo; principle&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;an-introduction-to-the-tools&#34;&gt;An Introduction to the Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Testing Tools are introduced in the chapter

&lt;ul&gt;
&lt;li&gt;JUnit and JMock are mentioned&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;JavaScript Test Runners like &lt;code&gt;ava.js&lt;/code&gt;, &lt;code&gt;mocha.js&lt;/code&gt;, and &lt;code&gt;jest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sinon.js&lt;/code&gt;, and &lt;code&gt;testdouble.js&lt;/code&gt; serve as mocking libraries&lt;/li&gt;
&lt;li&gt;Test Fixtures are mentioned in this chapter as well&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kick-starting-the-test-driven-cycle&#34;&gt;Kick-Starting the Test-Driven Cycle&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Using Test Fixtures and Mock Objects is mentioned&lt;/li&gt;
&lt;li&gt;Examples are using JUnit and JMock&lt;/li&gt;
&lt;li&gt;A test fixture is the fixed state that exists at the start of a test.&lt;/li&gt;
&lt;li&gt;A test fixture ensures that a test is repeatable

&lt;ul&gt;
&lt;li&gt;Every time a test is run it starts in the same state so it should produce the same results.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A fixture may be set up before the test runs and torn down after it has finished&lt;/li&gt;
&lt;li&gt;Assertion Libraries are talked about but mainly how to write tests using assertions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;maintaining-the-test-driven-cycle&#34;&gt;Maintaining The Test-Driven Cycle&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Start each feature with an acceptance test&lt;/li&gt;
&lt;li&gt;An acceptance test basically is how you test a feature in a UI&lt;/li&gt;
&lt;li&gt;An acceptance test should fail unti the feature is implemented&lt;/li&gt;
&lt;li&gt;Find the simplest success case&lt;/li&gt;
&lt;li&gt;User Acceptance Tests (UATs) should be easy to read&lt;/li&gt;
&lt;li&gt;You should be unit testing behavior and not methods&lt;/li&gt;
&lt;li&gt;Pay attention to trouble areas that are hard to test

&lt;ul&gt;
&lt;li&gt;This indicates a possible area for refactoring&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;object-oriented-style&#34;&gt;Object-Oriented Style&lt;/h2&gt;

&lt;p&gt;Object Oriented Design:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Have clear &lt;code&gt;separation of concerns&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Behavior should be grouped in logical places&lt;/li&gt;
&lt;li&gt;This helps isolate changes to &lt;code&gt;areas of concern&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Group components into &lt;code&gt;Higher Levels of Abstraction&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Don&amp;rsquo;t program with variables and control flow in mind but instead with larger abstractions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Encapsulation is a concept where behavior of an object is only affected through its API&lt;/li&gt;
&lt;li&gt;Information Hiding deals with the fact that Objects should hide lower level work in its API from public use&lt;/li&gt;
&lt;li&gt;Every object should have only have responsibility aka &lt;code&gt;Single Responsibility Principle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Composition of several objects should be simpler than the sum of all the objects&lt;/li&gt;
&lt;li&gt;Objects should have enough &lt;code&gt;context&lt;/code&gt; of their environment&lt;/li&gt;
&lt;li&gt;Whatever information you need should be passed in or to put it another way you can use &lt;code&gt;dependency injection&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;achieving-object-oriented-design&#34;&gt;Achieving Object-Oriented Design&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Writing test first influence the design of a system&lt;/li&gt;
&lt;li&gt;TDD with mock objects expresses intent that you should mock an object&amp;rsquo;s peer dependencies but not the internals of an object&lt;/li&gt;
&lt;li&gt;Value types is mentioned with explicit caveat that they are immmutable while Objects are stateful&lt;/li&gt;
&lt;li&gt;An object should be broken apart if it becomes difficult to test&lt;/li&gt;
&lt;li&gt;Interfaces should be not be fat and with that being said you will need more interfaces&lt;/li&gt;
&lt;li&gt;You will need more interfaces in order to keep your interfaces &lt;code&gt;lean&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;This means you should refactor interfaces as well&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;System Behavior should rely on composition and not inheritance&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;building-on-third-party-code&#34;&gt;Building on Third-Party Code&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;You should only mock object that you own&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t mock third party code&lt;/li&gt;
&lt;li&gt;Instead write an Adapter Layer&lt;/li&gt;
&lt;li&gt;Write a Database Adapter Layer so that if you change databases you can easily swap them out&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;commissioning-on-auction-sniper&#34;&gt;Commissioning on Auction Sniper&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A user scenario is described in this chapter detailing the auction process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-walking-skeleton&#34;&gt;The Walking Skeleton&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;In this chapter the first test is described which is an end to end test&lt;/li&gt;
&lt;li&gt;One example library that comes to mind is &lt;code&gt;Nightwatch.js&lt;/code&gt; and &lt;code&gt;Cypress.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;These libraries help you write end to end tests in modern web UIs&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;passing-the-first-test&#34;&gt;Passing the First Test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;TODOLIST&lt;/em&gt; is used in this chapter and the first item is crossed out&lt;/li&gt;
&lt;li&gt;An important concept that I derive is that User Workflows help influence the design and indicate important UI elements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;chapters-12-to-18&#34;&gt;Chapters 12 to 18&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;These chapters essential detail iterating through software design&lt;/li&gt;
&lt;li&gt;Small slices of behavior should be tested and implemented iteratively&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t be afraid of changing design of the system while iterating through a User Workflow&lt;/li&gt;
&lt;li&gt;Architecture should be developed incrementally&lt;/li&gt;
&lt;li&gt;Types in a system should be defined with &lt;code&gt;Domain Types&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Modelling systems with &lt;code&gt;Domain Types&lt;/code&gt; helps better describe a software system&lt;/li&gt;
&lt;li&gt;Avoid using Magic Numbers or Strings&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;handling-failure&#34;&gt;Handling Failure&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use smaller methods or utility methods that act as helpers for objects&lt;/li&gt;
&lt;li&gt;Logging should be designed as a feature

&lt;ul&gt;
&lt;li&gt;Avoid scattering logging statements all throughout a system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;listening-to-the-tests&#34;&gt;Listening to the Tests&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;An interesting point is made that implicit dependencies are still dependencies&lt;/li&gt;
&lt;li&gt;A good corollary to this can be made with npm dependencies&lt;/li&gt;
&lt;li&gt;Typically npm dependencies have dependencies of their own and if not isolated they carry an implicit dependency of their own&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t mock values or immutable values since you can just create instances but instead mock stateful objects&lt;/li&gt;
&lt;li&gt;Bloated &lt;code&gt;constructors&lt;/code&gt; ones that take many parameters should signal a refactor possibly add a service or a message broker&lt;/li&gt;
&lt;li&gt;Bloated &lt;code&gt;constructors&lt;/code&gt; can also signal that an object has too many responsilities&lt;/li&gt;
&lt;li&gt;You shouldn&amp;rsquo;t have too many test assertions in any given test this probably signals that you should broke apart a test&lt;/li&gt;
&lt;li&gt;A test should have few assertions/expectations&lt;/li&gt;
&lt;li&gt;Knowledge of an object should be as close to the origin

&lt;ul&gt;
&lt;li&gt;Keeping knowledge close helps make pluggable components&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;We should explicitly name a behavior to help control the behavior&lt;/li&gt;
&lt;li&gt;Try to add more names in order to extract more domain information&lt;/li&gt;
&lt;li&gt;Pass behavior rather than data&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;test-readability&#34;&gt;Test Readability&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Test Names should describe Features of a system&lt;/li&gt;
&lt;li&gt;Tests should follow a structure like this:

&lt;ul&gt;
&lt;li&gt;Setup&lt;/li&gt;
&lt;li&gt;Execute Actions&lt;/li&gt;
&lt;li&gt;Teardown&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Test structure should help explain behavior and should help share valuable information&lt;/li&gt;
&lt;li&gt;Delegate to subordinate objects&lt;/li&gt;
&lt;li&gt;Assertions/Expectations should communicate the exact behavior of a system&lt;/li&gt;
&lt;li&gt;Avoid magic variables and instead use constants that explicitly show intent&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;constructing-complex-test-data&#34;&gt;Constructing Complex Test Data&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A builder pattern helps in constructing complex test data&lt;/li&gt;
&lt;li&gt;Builder pattern helps break apart complex test data into some chainable methods&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;test-diagnostics&#34;&gt;Test Diagnostics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tests are made to fail&lt;/li&gt;
&lt;li&gt;We want tests to fail or report failures when they occur&lt;/li&gt;
&lt;li&gt;Write small and focused tests that are well named&lt;/li&gt;
&lt;li&gt;Add explanatory statements in test assertion/expections to help find error in a stack trace&lt;/li&gt;
&lt;li&gt;Use test matchers for detailing methods&lt;/li&gt;
&lt;li&gt;Tests should be self describing&lt;/li&gt;
&lt;li&gt;Tracer objects help map where failures occur&lt;/li&gt;
&lt;li&gt;Write a Failing Test ==&amp;gt; Make Diagnostics Clear ==&amp;gt; Make Tests Pass ==&amp;gt; Refactor&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;test-flexibility&#34;&gt;Test Flexibility&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Write precise assertions/expectations or just test the relevant parts of a method&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;chapters-25-to-27&#34;&gt;Chapters 25 to 27&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Persistence or CRUD actions can be tested with fine-grained integration tests&lt;/li&gt;
&lt;li&gt;Unit testing concurrent code can be difficult and it is easy to receive false positives&lt;/li&gt;
&lt;li&gt;Test Asychronous code by testing incremental changes in the UI&lt;/li&gt;
&lt;li&gt;Using timers can deliver false positives on UI changes&lt;/li&gt;
&lt;li&gt;Take snapshots of the UI throughout the lifecycle of the User Workflow&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
